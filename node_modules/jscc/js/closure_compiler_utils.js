/**
 * @define {boolean}
 */
var GOOG = false;

/**
 * @define {boolean}
 */
var DEBUG = true;
if (!GOOG) {
  var goog = {
        /**
         * @param {!string} ns
         * @returns {!Object}
         */
        provide : function (ns) {
          if (typeof ns !== "string") {
            ns = "";
          }
          ns = ns || "";

          /**
           * @type {Array.<!string>}
           */
          var nsArray = ns.split(".");
          if (nsArray.length > 1) {
            return goog.extendNamespace(nsArray, false);
          } else {
            if (!(ns in window)) {
              window[ ns ] = {}
            }
            return window[ ns ];
          }
        },

        /**
         * @param {!Array} nsArray
         * @param {!boolean} isfatal
         * @param {!Object=} tmpSpace
         * @returns {!Object}
         * @throws {TypeError}
         */
        extendNamespace : function (nsArray, isfatal, tmpSpace) {
          /**
           * @type {Object}
           */
          var temporarySpace = tmpSpace || window;

          /**
           * @type {(!string|undefined)}
           */
          var temporaryName;
          for (var i = 0,len = nsArray.length; i < len; ++i){
            temporaryName = nsArray [ i ];
            if (!(temporaryName in temporarySpace)) {
              if (!isfatal) {
                temporarySpace[ temporaryName ] = {};
              } else {
                try {
                  throw new TypeError("namespace " + temporaryName + " is not exist.");
                } catch(e) {
                  throw new Error(e);
                }
              }
            }
            temporarySpace = temporarySpace[ temporaryName ];
          }
          return temporarySpace;
        },

        scope : function (fn) {
          fn();
        }
      }
}

goog.provide('ccu');
/**
 * @public
 * @param {!string} format_args
 * @param {...*} var_args
 * @returns {!string}
 */
ccu.fmt = function (format_args, var_args) {
  /**
   * @type {RegExp}
   */
  var reg;

  /**
   * @type {!string}
   */
  var format = ccu._shift.call(arguments);
  for (var i = 0, len = arguments.length; i < len; i++) {
    reg = new RegExp(("\\$\\{" + i + "\\}"), "g");
    format = format.replace(reg, arguments[i]);
  }
  return format;
}


/**
 * @constructor
 * @param {!Function} fn
 */
ccu.Policy = function (fn) {
  /**
   * @type {!Function}
   */
  this._fn = fn;
}

/**
 * @public
 * @param {!Arguments} args
 * @param {*} context
 * @param {!Object} policyType
 * @returns {*}
 */
ccu.Policy.invoke = function (args, context, policyType) {
  /**
   * @type {*}
   */
  var policy = args[0];
  if (policy instanceof ccu.Policy) {
    return ccu._shift.call(args)._fn.apply(context, args);
  }
  return policyType.defaultPolicy.apply(context, args);
}

/**
 * @private
 * @const
 * @param {Function} Class
 * @returns {!Object}
 */
ccu._createNoSideEffectInstance = function (Class) {
  if (!Class) {
    ccu.exceptions.raise(new ccu.exceptions.RuntimeException('The base class is not defined.'));
  }
  /**
   * @constructor
   */
  function noSideEffectConstructor(){}
  noSideEffectConstructor.prototype = Class.prototype;
  return new noSideEffectConstructor;
}

/**
 * @private
 * @const
 * @param {*} target
 * @returns {!boolean}
 */
ccu._isDefined = function isDefined (target) {
  return (target !== undefined && target !== null);
}

/**
 * @private
 * @const
 * @param {Array.<string>} obj
 * @param {Function} fn
 * @param {number} index
 */
ccu._addFnToStack = function addFnToStack (obj, fn, index) {
  if (fn) {
    obj[index] = '----' + ((fn.name)? fn.name : 'anonymous') + '----\n' + fn.toString();
  } else {
    obj[index] = '[global-code]';
  }
}

/**
 * @private
 * @const
 * @returns {!Array.<string>}
 */
ccu._getCallStack = function getCallStack() {
  /**
   * @type {Function}
   */
  var self = arguments.callee.caller;

  /**
   * @type {!number}
   */
  var i = 0;

  /**
   * @type {!Array.<string>}
   */
  var ret = [];

  ccu._addFnToStack(ret, self, i);
  if (self) {
    while (1) {
      if (self) {
        self = self.arguments.callee.caller;
        ccu._addFnToStack(ret, self, i);
        if (!self) {break;}
      } else {
        ccu._addFnToStack(ret, self, i);
        break;
      }
      i++;
    }
  }
  return ret;
}

/**
 * @private
 * @const
 */
ccu._Constant = {
  /**
   * @const
   * @type {!string}
   */
  NODE : "Element",

  /**
   * @const
   * @type {!string}
   */
  UNDEFINED : 'undefined',

  /**
   * @const
   * @type {!string}
   */
  NULL : 'null',

  /**
   * @const
   * @type {!RegExp}
   */
  OBJECT_TYPE_REG : /\[object\s(\w+)\]/
}

/**
 * @private
 * @const
 * @type {function () : string}
 */
ccu._toString = Object.prototype.toString;

/**
 * @private
 * @const
 * @type {Function}
 */
ccu._shift = Array.prototype.shift;

/**
 * @private
 * @const
 * @type {Function}
 */
ccu._unshift = Array.prototype.unshift;

/**
 * @private
 * @const
 * @type {Function}
 */
ccu._slice = Array.prototype.slice;

/**
 * @private
 * @const
 * @type {Function}
 */
ccu._pop = Array.prototype.pop;


/**
 * @param {*} obj
 * @returns {!string}
 */
ccu.typeOf = function (obj) {
  if (obj && obj.nodeType) {
    return ccu._Constant.NODE;
  }
  if (obj === undefined) {
    return ccu._Constant.UNDEFINED;
  } else if (obj === null) {
    return ccu._Constant.NULL;
  }
  /**
   * @type {!string}
   */
  var ret = ccu._toString.call(obj);
  return ret.replace(ccu._Constant.OBJECT_TYPE_REG, "$1");
}

/**
 * @param {!Function} Class
 * @param {!Function} inheritance
 * @returns {!Function}
 */
ccu.extendClass = function (Class, inheritance) {
  if (!Class) {
    ccu.exceptions.raise(new ccu.exceptions.RuntimeException('The derived class definition is not defined.'));
  }
  if (!inheritance) {
    ccu.exceptions.raise(new ccu.exceptions.RuntimeException('The inheritance is not defined.'));
  }
  Class.prototype = ccu._createNoSideEffectInstance(inheritance);
  /**
   * @param {...*} var_args
   */
  Class.prototype.constructor = Class;
  Class.Super = inheritance;
  return Class;
}

/**
 * @param {Function} constructor
 * @param {!Object} def
 */
ccu.proc = function (constructor, def) {
  ccu.objects.extend(ccu.extendPolicy.throwIfConflict, constructor.prototype, def);
}

/**
 * @param {!Function} Class
 * @param {!Object} traits
 */
ccu.mixinTrait = function (Class, traits) {
  for (var i = 0,len = traits.length; i < len; i++) {
    /**
     * @type {!string}
     */
    var prop;
    for (prop in traits[i]) {
      Class.prototype[prop] = traits[i][prop];
    }
  }
};

/**
 * @type {!Object}
 */
ccu.classUtil = {
  /**
   * @param {!Function} constructor
   * @param {!Array.<*>} args
   * @returns {*}
   * @throws {ccu.exceptions.RuntimeException}
   */
  applyNew : function (constructor, args) {
    if (!constructor) {
      try {
        throw new ccu.exceptions.RuntimeException("ClassUtil.applyNew need class definition that created by Function Class.");
      } catch(e) {
        throw new Error(e);
      }
    }
    /**
     * @type {!Object}
     */
    var instance = ccu._createNoSideEffectInstance(constructor);
    constructor.apply(instance, args);
    return instance;
  },

  /**
   * @param {!Object} instance
   * @param {!Function} parent
   * @returns {!boolean}
   */
  isInstance : function (instance, parent) {
    return (ccu._isDefined(instance)  && ccu._isDefined(parent))? instance instanceof parent : false;
  }
}

/**
 * @type {!Object}
 */
ccu.functions = {
  /**
   * @public
   * @static
   * @param {!Function} fn -> 何らかの値を返す関数
   * @return {!function(...[*]) : *} -> キャッシュ機能付き関数
   * @description
   * 引数fnを一度だけ実行し、
   * 二度目以降の呼び出しの際には、その結果を返す関数を返す
   */
  cache : function (fn) {
    /**
     * @param {...*} var_args
     * @returns {*}
     */
    var wrapper = function (var_args) {
          if (wrapper._result) {
            return wrapper._result;
          } else {
            /**
             * @type {*}
             */
            var result = wrapper._function.apply(this, arguments);
            /**
             * @type {*}
             */
            wrapper._result = result;
            return result;
          }
        }
    /**
     * @type {!Function}
     */
    wrapper._function = fn;
    /**
     * @type {!function():undefined}
     */
    wrapper.clear = function () {
      delete this.__result__;
    }
    return wrapper;
  },

  /**
   * @static
   * @param {Function} fn -> 包みたい関数
   * @return {!function(...[*]) : *}
   * @description
   * 引数fnをラップした関数を返す
   */
  wrap : function (fn) {

    if (!fn && typeof fn !== "function") {
      try {
        throw new ccu.RunTimeException("The arguemnts of Function.wrap must be a funciton.");
      } catch(e) {
        throw new Error(e);
      }
    }

    /**
     * @param {...*} var_args
     * @returns {*}
     */
    return function (var_args) {
      return fn.apply(this, arguments);
    }
  },

  /**
   * @public
   * @static
   * @param {!Function} fn -> 一度だけ実行したい関数
   * @return {!function(...[*]) : *} -> 一度だけしか実行しない関数
   * @description
   * 引数fnを一度だけ実行する関数を返す
   */
  once : function (fn) {
    /**
     * @param {...*} var_args
     * @returns {*}
     */
    var wrapper = function (var_args) {
          if (!wrapper._done) {
            wrapper._done = true;
            return wrapper._function.apply(this, arguments);
          }
        }
    /**
     * @type {!Function}
     */
    wrapper._function = fn;
    /**
     * @type {!boolean}
     */
    wrapper._done = false;
    return wrapper;
  }
}

/**
 * @type {!Object}
 */
ccu.objects = {
  /**
   * @public
   * @static
   * @param {!Object} target
   * @param {!Object} expected
   * @throws {ccu.NotImplementedException}
   * @description
   * 実装のチェック。
   * デバッグ用
   */
  ensureImplementation : function (target, expected) {
    for (var prop in expected) {
      if (!(prop in target)) {
        try {
          throw new ccu.NotImplementedException(prop);
        } catch (e) {
          throw new Error(e);
        }
      }
      if (ccu.typeOf(target[prop]) !== expected[prop]) {
        try {
          /**
           * @type {!string}
           */
          var message = ccu.fmt("${0} expected ${1}, but got ${2}", prop, expected[prop], ccu.typeOf(target[prop]));
          throw new TypeError(message);
        } catch (e) {
          throw new Error(e);
        }
      }
    }
  },

  /**
   * @static
   * @public
   * @param {...*} var_args
   * @return {*}
   * @throws {RunTimeException}
   * @description
   * 引数destを引数sourceで拡張する。
   */
  extend : function (var_args) {
    return ccu.Policy.invoke(arguments, ccu.objects, ccu.extendPolicy);
  }
}

/**
 * @type {!Object}
 * @public
 */
ccu.extendPolicy = {}

/**
 * @type {!ccu.Policy}
 */
ccu.extendPolicy.overwrite = new ccu.Policy(
  /**
   * @param {!Object} dest
   * @param {!Object} source
   * @returns {!Object}
   */
  function (dest, source) {
    for (var i in source) {
      dest[i] = source[i]
    }
    return dest;
  })

/**
 * @type {!ccu.Policy}
 */
ccu.extendPolicy.notOverwrite = new ccu.Policy(
  /**
   * @param {!Object} dest
   * @param {!Object} source
   * @returns {!Object}
   */
  function (dest, source) {
    for (var i in source) {
      if (!(i in dest)) {
        dest[i] = source[i];
      }
    }
    return dest;
  })

/**
 * @type {!ccu.Policy}
 */
ccu.extendPolicy.throwIfConflict = new ccu.Policy(
  /**
   * @param {!Object} dest
   * @param {!Object} source
   * @param {!Object=} except
   * @returns {!Object}
   */
  function (dest, source, except) {
    except = except || {};
    for (var i in source) {
      if (i in dest && !(i in except)) {
        ccu.exceptions.raise(new ccu.exceptions.RuntimeException(i + ' is conflicted.'));
      } else {
        dest[i] = source[i];
      }
    }
    return dest;
  })

/**
 * @type {!ccu.Policy}
 */
ccu.extendPolicy.defaultPolicy = ccu.extendPolicy.overwrite;

/**
 * @namespace
 * @type {!Object}
 */
ccu.exceptions = {}

/**
 * @public
 * @constructor
 * @param {!string} type
 * @param {!string} message
 */
ccu.exceptions.Exception = function (type, message) {
  /**
   * @type {!string}
   */
  this._errorType = type;
  /**
   * @type {!string}
   */
  this._errorMessage = message;

  /**
   * @type {!Array.<string>}
   */
  this._callstack = ccu._getCallStack();
}

ccu.proc(
  ccu.exceptions.Exception,
  /**
   * @lends ccu.exceptions.Exception.prototype
   */
  {
    /**
     * @param {!string} msg
     */
    appendMessage : function (msg) {
      this._errorMessage += msg;
    },

    /**
     * @param {!string} msg
     */
    resetMessage : function (msg) {
      this._errorMessage = msg;
    },

    /**
     * @returns {!string}
     */
    toString : function () {
      return this._errorType + ' : ' + this._errorMessage + '\n------called from------\n' + this._callstack.join('\n');
    }
  });

/**
 * @param {!Object} error
 * @throws {Error}
 */
ccu.exceptions.raise = function (error) {
  try {
    throw error
  } catch (e) {
    throw new Error(e);
  }
}

/**
 * @public
 * @constructor
 * @extends {ccu.exceptions.Exception}
 * @param {!string} msg
 */
ccu.exceptions.RuntimeException = function (msg) {
  ccu.exceptions.RuntimeException.Super.call(this, "RuntimeException", msg);
}
ccu.extendClass(ccu.exceptions.RuntimeException, ccu.exceptions.Exception);

/**
 * @public
 * @constructor
 * @param {!string} msg
 * @extends {ccu.exceptions.Exception}
 */
ccu.exceptions.NotImplementedException = function (msg) {
  ccu.exceptions.RuntimeException.Super.call(this, 'NotImplementedException', msg)
}
ccu.extendClass(ccu.exceptions.NotImplementedException, ccu.exceptions.Exception);

if (DEBUG) {
  /**
   * @constructor
   * @param {!string} message
   * @extends {ccu.exceptions.Exception}
   */
  ccu.AssertionError = function (message) {
    ccu.exceptions.RuntimeException.Super.call(this, "AssertionError", message);
  }
  ccu.extendClass(ccu.AssertionError, ccu.exceptions.Exception);

  if (console && console.assert && typeof console.assert === 'function') {
    ccu.assert = console.assert.bind(console);
  } else if (console && console.assert) {
    /**
     * @param {!boolean} x
     */
    ccu.assert = function (x) {
      console.assert(x);
    }
  } else {
    /**
     * @param {!boolean} ok
     */
    ccu.assert = function (ok) {
      if (!ok) {
        ccu.exceptions.raise(new ccu.AssertionError("assertion failed."));
      }
    }
  }
} else {
  /**
   * @param {!boolean} x
   */
  ccu.assert = function (x){}
}
