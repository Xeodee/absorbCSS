fs = require 'fs'
path = require 'path'
require 'colors'
{DepsFinder} = require './deps_finder'
{log} = require './logger'
{CompilerFactory, merge} = require './compiler_factory'
{CompilationInfo} = require './compilation_info'
{DEFAULT_DEPS_FORMAT} = require './default_deps_format'
DEPS_REG = /\$\{DEPS_LIST\}/g

class CompileRunner
        constructor : (compilationInfo) ->
                @_compilationInfo = compilationInfo
                @_watcher = fs.watch @_compilationInfo.filename(), persistent : true, (event) =>
                        if event is 'change' and @_compilationInfo.modefied()
                                @_compilationInfo.update()
                                CompileRunner.compile(@_compilationInfo)

        unwatch : -> @_watcher.close()
                                        
        updateCompilationInfo : (compilationInfo) ->
                @_compilationInfo = compilationInfo


        @compile : (compilationInfo)->
                compilerName = compilationInfo.compilerName()
                compiler = CompilerFactory.create(compilerName, compilationInfo, CompileRunner._writeFile.bind(null, compilationInfo))
                compiler.compile()

        @_writeFile : (compilationInfo, data, warnings = [0, 0], errors = [0, 0]) ->
                fs.writeFile compilationInfo.output(), data, compilationInfo.charset(), (err) =>
                        if err
                                log err
                        else 
                                log "#{compilationInfo.target()}\n#{errors[1]} error(s)  #{warnings[1]} warning(s)", 'Compile Successed'
                DepsWriter.write compilationInfo.filename(), compilationInfo.deps(), compilationInfo.baseDir(), compilationInfo.depsFormat()
                

class JsonParseError
        constructor : (message) ->
                @_message = message

        toString : ->
                message = @_message
                return "JSON.parse error. #{message}"

class JsonUpdater
        constructor : (path, callback)->
                @_path = path
                @_json = JsonUpdater.readJson(path)
                @_callback = callback

        watch : ->
                fs.watch @_path, persistent : true, (event) =>
                        log "#{@_path} is updated!"
                        @_json = JsonUpdater.readJson(@_path)
                        @_callback @_json

        run : ->
                @_callback @_json

        @readJson : (name) ->
                try
                        json = fs.readFileSync name, 'utf-8'
                catch e
                        console.error "#{e.message} in #{name}"
                try
                        json = JSON.parse json
                catch e
                        throw new JsonParseError "#{e.message} in #{name}"
                json
                        

class Runner 
        constructor : (mode) ->
                @_watchers = {}
                @_depends = []
                @_ignored = {}
                @_mode = mode
                @_initialize()

        append : (path, target, options, json) ->
                if not @_watchers[path]
                        compilationInfo = new CompilationInfo @_mode, path, target, options, @_depends, @_ignored, json
                        @_depends.push path
                        @_watchers[path] = new CompileRunner compilationInfo

        reset : ->
                @_depends = []
                for filename, watcher of @_watchers
                        watcher.unwatch()
                @_watchers = {}

        _initialize : ->
                if fs.existsSync "#{process.cwd()}/ignored.json"
                        updater = new JsonUpdater "#{process.cwd()}/ignored.json", (json) =>
                                if json.ignored
                                        for i in json.ignored
                                                if fs.existsSync i
                                                        @_ignored[fs.realpathSync(i)] = 1
                        updater.watch()
                        updater.run()

class DepsWriter
        @write : (filename, deps, baseDir, format)->
                format = format ? DEFAULT_DEPS_FORMAT
                if deps
                        pathOfDepsFile = deps
                        paths = [];
                        DepsFinder.search filename, (jspath, target) ->
                                if baseDir
                                        paths.push(path.relative(fs.realpathSync(baseDir), jspath))
                                else
                                        paths.push(jspath)
                        fs.writeFile pathOfDepsFile, format.replace(DEPS_REG, "#{JSON.stringify(paths, null, '  ')}"), 'utf-8'

exports.compressor = 
        run : (mode) ->
                runner = new Runner mode
                jsonUpdater = new JsonUpdater "#{process.cwd()}/build.json", (json) ->
                        runner.reset()
                        for k, v of json
                                if k isnt 'global'
                                        DepsFinder.search k, (path, target) ->
                                                runner.append path, target, v, json
                jsonUpdater.watch()
                jsonUpdater.run()

        deps : (r, opt) ->
                json = JsonUpdater.readJson("#{process.cwd()}/build.json")
                reg = new RegExp r.replace /([\.\/\-])/, '\\$1'
                for k, v of json
                        if reg.test k
                                DepsWrite.write v.deps

        build : (mode, r, opt) ->
                json = JsonUpdater.readJson("#{process.cwd()}/build.json")
                ignoredJson = JsonUpdater.readJson("#{process.cwd()}/ignored.json")
                deps = []
                ignored = {}
                options = undefined
                target = undefined
                reg = new RegExp r.replace /([\.\/\-])/, '\\$1' 
                console.log "Compile target which matched #{reg.toString().yellow}"
                for k, v of json
                        if reg.test k
                                options = v
                                target = fs.realpathSync k
                                DepsFinder.search k, (path, target) ->
                                        deps.push path
                for i in ignoredJson.ignored
                        ignored[ignoredJson.ignored[i]] = 1
                if options
                        if opt
                                merge options, JSON.parse opt[0]
                        compilationInfo = new CompilationInfo mode, target, target, options, deps, ignored, json
                        CompileRunner.compile compilationInfo

